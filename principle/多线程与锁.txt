一、sychronize锁升级过程
sychronize锁存放在java对象头中,对象头里面的Mark Word默认存储对象的hashcode、分代年龄和锁标记位
锁一共有4种状态,分别为无锁|偏向锁|轻量级锁|重量级锁
1.无锁(标志位为00,锁状态为0):此时被称为可偏向状态,所有对象被创建出来的时候锁的类型都为01
2.偏向锁(标志位01,锁状态为1):jdk 1.6引入
	所有对象被创建出来时锁标志位为01,锁状态为0,当线程执行到临界区(sychronize包裹住的代码块)时,会利用CAS操作将线程ID插入到mark word中,同时修改锁的状态为1
	偏向锁的获取:
		当再次进入到临界区(sychronize)时,会拿当前线程ID与mark word中的ID作对比
			如果一致,则说明线程已经成功获得了锁
			如果不一致,会检查该偏向锁是否还可偏向(状态是否为0).
			如果还未偏向(状态为0)则加上偏向锁(CAS)
			如果已偏向,则会进行锁升级
	偏向锁的释放:
		偏向锁是十分轻量级的,线程不会主动释放偏向锁,需要等待其他的线程来竞争
		偏向锁在没有字节码运行的时候会去检查偏向锁所在的线程时候活动,从而释放锁(会stop the world),可以通过参数关闭轻量级锁
3.轻量级锁(标志位00):
	当锁升级为轻量级锁时,其他线程会通过自旋来尝试获取锁,线程不会阻塞,从而提高性能
	轻量级锁的获取:
		当锁对象的Mark World表示其为无锁状态时,获取锁的线程尝试将该对象的Mark world拷贝到自己的锁空间(在线程中建立),并尝试使用CAS操作来来尝试修改其对象头中的线程ID
		如果成功,则获取到该锁对象,并将其mark world中的锁标志位改为00(轻量级锁)
	轻量级锁的释放:
		当临界区执行完成后,会将锁表示改变为无锁
4.重量级锁(标志位10):
	重量级锁是由轻量级锁膨胀而来的,以下情况会出现锁的膨胀
		a.仅有一个线程等待锁,并且自旋次数过多
		b.有一个以上线程锁等待,则升级为重量级锁(防止CPU空转)
	重量级锁的获取:
		重量级锁是java最基础的锁实现,将没有获得锁的线程进行阻塞
		重量级锁之所以重量级,是因为他通过内部的Monitor来实现,该实现依赖于操作系统,此时操作系统会从用户态转为内核态,相对来说比较消耗资源
	重量级锁的释放:
		重量级锁释放后,或notify一个新的线程来使用锁
5.思考:为什么要分为这三种状态?
	1)对象在创建的时候认为自己不会被多线程争夺,默认使用偏向锁,偏向锁非常轻量级只需要使用CAS操作即可完成加锁
	2)当有少量竞争的时候使用轻量级锁,这时候使用的是自旋,因为有的临界区内代码并不多,且竞争线程少,此时如果转为锁阻塞状态会得不偿失
	3)当有多个线程竞争锁或者一个线程等待过长时,轻量级锁的意义就不存在了,CPU可能长时间空转,此时不如将这些线程锁阻塞,让CPU时间片分配到真正活动的线程
二、线程的状态:
这些状态都是Java Thread类中的Enum值
1.NEW:线程还没有被启动过
2.RUNNABLE:可执行状态表示一个线程正在执行或者也可以是在等待其他资源
3.BLOCKED:锁阻塞状态表示一个线程正在等待一个monitor lock以进入临界区(sychroniezd)
4.WAITTING:等待状态表示该线程执行了以下方法之一:Object.wait(),Thread.join()
5.TIMED WAITTING:同上(with time out)
6.TERMINATTED:已经完成了运行.即将终止
5.CAS(compare and swap)有什么问题:ABA问题
6.强引用,软引用,弱引用有什么区别