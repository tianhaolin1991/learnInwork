## 第六章:优先队列-堆
- 队列是一个排队的好机制,但是如果有紧急的任务,希望能够优先处理,这时候就需要使用到优先队列
>#### 模型
- [ ] 优先队列允许至少以下两种操作
- 1.insert:插入,相当于enqueue入队操作
- 2.deleteMin:删除最小(或最大),相当于dequeue出队操作
- [ ] 应用
- 操作系统
- 贪婪算法
>#### 二叉堆
- [ ] 结构性质
- 堆是一颗完全二叉树,所以<font color=red>实际实现可用轻易使用数组实现</font>
```text
这意味着堆可以用一个数组来表示
这样唯一的问题是我们需要预先估计数组的大小
```
- [ ] 堆序性质
- 堆及堆中的每一个子堆,其最小(大)值都在根节点上,称为小(大)顶堆
- [ ] 基础的堆操作
- 1.插入(insert)
```text
将元素X插入到堆中,我们在下一个可用位置创建一个空穴
    如果插入X不影响堆的结构,则直接将X放入空穴位置
    如果插入X英系那个堆的结构,则将X上冒,直到重新形成一个堆
    
这种上冒的操作被称为上滤
```
- 2.deleteMin:删除最小单元
```text
我们将堆顶元素删除并添加一个空穴,将树中的最后一个元素放到空穴中
空穴与其左右孩子中较小的一个进行交换,重复以上动作直到成为一个新的堆

这种下沉的操作被称为下滤
```
>#### 优先队列的应用
- [ ] 选择问题
- 输入N个元素以及一个整数k,找出第k个最大的元素
```text
算法1A:
    将元素读入数组并将它们排序,返回适当的元素,时间复杂度为O(排序)
算法1B:
    我们将N个元素读入一个大小为k的数组,并进行排序
    读入第k+1个元素,与数组中的数据依次比较,如果新元素较大,则将第k个元素除去.将新元素放到合适的位置上
    这种算法的时间复杂度为O(N*k),如果k=N/2,则时间复杂度为O(N^2)
    
堆:
算法6A:
    将N个元素读入数组,然后使用BuildHeap方法,该方法时间复杂度最坏情形为O(N)
    然后执行k次deleteMax,时间复杂度为O(k*logN)
    总时间复杂度为O(N+k*logN),k小时,复杂度为O(N),k大时,复杂度为O(k*logN)
算法6B:
    借鉴1B的思路,但是使用大顶堆来实现
    前k个元素构建一个堆,时间复杂度为O(k)
    如果新元素更大,则弹出Sk并插入新元素,时间复杂度为O((N-k)*logk)
    因此总时间为O(k+(N-k)logk) = O(Nlogk)
```
