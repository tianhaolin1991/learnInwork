## 第三章:表、栈和队列
### ADT:抽象数据类型(abstract data type)
### 表(list)ADT
- 表的常见实现有数组和链表
>#### 数组
- 连续存储
- 查询快,增删慢(需要移动)
>#### 链表
- 非连续存储
- 查询慢,增删快
### 栈ADT
>#### 定义:栈是限制插入和删除只能在一个位置上进行的表,该位置是表的末端,叫做栈顶(top)
- 栈也叫做后进先出表(LIFO) ==> last in first out
>#### 栈的实现
- 1.链表:单链表,通过在表的顶端插入实现push,删除顶端元素实现pop
- 2.数组:模仿arrayList的做法->
>#### 栈的应用
- 1.平衡符号(如编译器)
- 2.中缀后缀转换
```
将中缀表达式 a+b*c+(d*e+f)*g 转换为标准后缀表达式: abc*+de*f+g*+
方法:当读到一个操作数后,立即将他放到输出中,操作符不立即输出,先存在栈中
    a)如果遇见一个右括号,那么将栈元素弹出,将弹出的符号写出直到遇到一个对应的左括号
    b)如果我们遇到任何其他的符号,+,*,( 那么我们从栈中弹出栈元素,直到发现优先级更低的元素为止,
        其中+,*,(优先级从低到高
    step:
    栈:     输出: a
    栈:+    输出: a
    栈:+    输出: ab
    栈:+*   输出: abc  => *号输入,发现*号比+优先级高,所以入栈而没有输入
    栈:+    输出: abc*+ => +号输入,发现+号比*优先级低,所以弹出*+,然后将+入栈
    栈:+(   输出: abc*+de*f+ =>*优先级低于(,顾输出*
    栈:     输出: abc*+de*f+g*+
```
- 3.计算后缀表达式的值
```
abc*+de*f+g*+
方法:遇到运算符后弹出两个操作数,并计算结果后入栈
栈: a b c ,遇到*弹出bc并运算再入栈
栈: a b*c ,遇到+弹出运算再入栈
栈: a+(b*c) d*e f 
栈: a+(b*c) d*e+f g
栈: a+(b*c) (d*e+f)*g
栈: a+b*c+(d*e+f)*g
```
- 4.方法调用
### 队列ADT
