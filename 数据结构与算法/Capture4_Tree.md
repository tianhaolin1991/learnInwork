## 第四章:树
- 树的大部分操作运行时间为O(logX(N)),其中X为其叉数
### 预备知识
>#### 基本定义
一颗树是N个节点和N-1条边组成的,其中一个节点是根,其他的节点都存在父节点
- 根: root节点
- 叶子节点: 度为0,没有子节点的节点被称为树叶
- 节点深度: 从根节点到该节点的唯一路径的长,因此根节点的深度为0
- 树的高度: 最大的节点深度
- 度: 指的是一个节点拥有子节点的个数,如二叉树的叶子节点的最大度为2
>#### 树的实现方法
- 节点由3部分组成,数据,第一个儿子节点,下一个兄弟节点.这是一种树的实现方式

### 二叉树
- 二叉树是一颗树,其中每个节点最多有两个儿子
- 二叉树的深度最小可以达到O(logN),最大可以达到N-1
```
分别对应完全二叉树和每个节点没有兄弟节点且只有一个子节点的情况
```
- 完全二叉树
```text
度小于2的节点只能出现在最后两层的二叉树,并且其填满的顺序是从左到右
这保证了完全二叉树可以使用这样的数组表示(arr[0]为空,根节点在arr[1]上):
    对于数组中任一位置i上的元素,其左儿子在2i上,右儿子在2i+1上
```
- 满二叉树
```text
叶子节点只能在最后一层的二叉树
满二叉树是完全二叉树,且满二叉树删除叶子节点后可以退化为完全二叉树
```
>#### 二叉查找树
- 定义: 对于二叉树中的每一个节点X,其左子树中的所有节点均小于X,而它的右子树中的所有项的值均大于X
- 二叉查找树的平均栈深度为O(logN)
- 如果二叉查找树随机生成,对于排序好的数据,二叉查找树的深度可能到达N-1,为了保证操作的速度,我们引入了平衡树
>#### AVL树
-[ ] 定义: AVL树是一种带有平衡条件的二叉查找树
```
它要求平衡条件容易保持,并且保证树的深度是O(logN)

一颗AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树(空树的高度定义为-1)
一个AVL树的高度最多为1.44log(N+2)-1.328,但是实际上的高度只略大于logN
```
-[ ] 旋转: 插入一个节点可能会破坏AVL树的特性,如果发生这种情况,需要考虑在这一步插入完成之前来修正树,称之为旋转
```
这里不考虑删除的情况,假设使用懒删除的方法(即将节点标记为删除,实际不删除)
实际上,这总是简单的修正既可以做到

我们需要重新平衡的节点称为N,则仅有4种不平衡情况
1.对N的左儿子的左子树进行一次插入
2.对N的右儿子的右子树进行一次插入
3.对N的左儿子的右子树进行一次插入
4.对N的右儿子的左子树进行一次插入
其中1/2,3/4是两种镜像对称,所以实际有两种情况(实际编码还是4中情况)
单旋转:
    1/2的方式通过但旋转即可实现重新平衡
        1.右旋:N的左子树根节点M变为整个子树的根节点,N变为当前根节点M的右子树,M的右子树变为N的左子树
        2.左旋:M的右子树根节点M变为真个子树的根节点,N变为当前根节点M的左子树,M的左子树变为N的右子树
双旋转:
    3/4的方式通过双旋转才可以实现重新平衡
        3.左-右双旋:先将N左子树的根节点M进行左旋,得到情形1,进行右旋
        4.右-左双旋:先将N右子树的根节点M进行右旋,得到情形2,进行左旋
```
-[ ] AVL树的java实现
- https://blog.csdn.net/funnyrand/article/details/81745518

>#### 树的遍历
- 中序遍历: 左根右
```text
中序遍历的运行总时间为O(N)
对于查找树,中序遍历可以按顺序列出所有节点的值
```
- 前序遍历: 根左右
```text
前序遍历的运行总时间为O(N)
有时我们需要先处理当前节点然后才能处理两颗子树,比如我们要给树的每一个节点加上一个深度的属性
```
- 后序遍历: 左右根
```text
后序遍历的运行总时间为O(N)
有时我们需要先处理两颗子树然后才能处理当前节点,比如计算节点的树的高度需要先知道子树的高度
```

### B树
>#### 什么是B树
- B树常常用于存储当中,它是M叉查找树的一种实现方式
```text
当数据很多的情况下(内存已经装不下),我们必须将数据结构放到磁盘上,此时大O模型不再适用(大O假设所有操作耗时相等)
一个7200转(RPM rates per minute)的磁盘,每秒可以访问120次
一台500MIPS的处理器,每秒可以执行5亿条指令.
所以需要提高程序效率时,减少磁盘IO是一个非常有效的手段

在磁盘上,典型的查找树执行如下:
假设需要访问有1000万项的记录,每个关键字时32个字节(key),而每个记录是256个字节.假设这些数据不能都装入内存
我们的计算机每秒可以执行2500万次指令,或者执行6次磁盘访问(性能是普通计算机的1/20)

不平衡的查找二叉树可能最多需要1000万次磁盘访问,平均次数是1.38logN,约32次磁盘访问,需要大约5秒
平衡树的典型情形是非常接近于logN,需要25次磁盘访问,约等于4秒
如果我们使用一颗M叉查找树(假设是完全M叉树),需要访问磁盘的次数就变为logM(N)
```
>#### B树的特性
- [ ] 阶为M的B树是一颗具有下列特征的树
- 1.关键字(key)
```text
1.每个节点最多有M-1个关键字
2.根节点最少有1个关键字(为叶子节点,或至少有两个子树),非根节点至少有M/2(向上取整)个关键字
3.每个节点中的关键字从小到大排列,每个关键字的左子树中的所有关键字都小于它,右子树中的所有关键字都大于它
```
- 2.节点
```text
1.每个节点都存放关键字和数据
2.叶子节点的深度是一样的
```
- [ ] 阶为M的B+树
- 1.关键字(和B树有区别)
```text
1.每个节点最多有M-1个关键字
2.跟节点最少有1个关键字(为叶子节点,或至少有两个子树),非根节点至少有M/2(向上取整)个关键字
3.每个节点中的关键字从小到大排列,每个关键字的左子树中的所有关键字都小于它,
  右子树中的所有关键字都大于等于它,关键字i代表子树i+1中的最小关键字(父节点存有右孩子的第一个元素的索引)
```
- 2.节点
```text
1.所有的数据都在叶子节点上
2.除了叶子节点其他的所有节点均只存放关键字
3.叶子节点形成一个有序链表

```
- B+树的优势
```text
1.由于B+数在内部节点(非叶子节点)上不存放数据信息,因此在内存页中能够存放更多的key,数据存放的更加紧密,具有更好的空间局部性
2.所有的查询都要找到叶子节点,查询性能稳定,而B树每个节点都可以查找到数据
3.B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。
  而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
```
- B树和B+树的区别: https://blog.csdn.net/weixin_30883777/article/details/96240352
- 为什么数据库使用B+树? https://blog.csdn.net/mocas_wang/article/details/109654253
