## 面向对象6大设计原则
- [ ] 开闭原则(Open-Closed Principle)
- 代码对拓展开放,对修改关闭.即软件实体应该尽量在不修改原有代码的情况下进行拓展
- 开闭原则是面向对象设计的主要思想和目标
- [ ] 单一职责原则(SRP: Single Responsibility Principle)
- 对一个类而言,只有一个引起其变化的原因
- 是否拆分一个类,需要取决于变化,当变化发生,只影响其中一个职责就需要拆分,如果影响全部职责,就不需要拆分
```text
单一职责原则不仅仅适用于类,也适用于方法
```
- [ ] 里氏代换原则(LSP: Liskov Substitution Principle)
- 所有引用父类的地方必须能够透明的使用子类的对象,即子类尽量不要重写父类的方法
- [ ] 依赖倒置原则(DIP: Dependency Inversion Principle)
- 具体应该依赖于抽象->面向对象编程
- [ ] 接口隔离原则(ISP: Interface Segregation Principle)
- 接口的功能应该隔离:不要造大接口,根据功能变为多个小接口
- [ ] 迪米特法则(LoD:Law of Demeter)
- 一个软件实体尽可能少地与其他实体发生互相作用: 不和陌生人说话
## 创建型模式
### 工厂模式
- 工厂模式是创建型模式
- 工厂模式的好处
```text
1.将创建对象的代码集中起来,避免代码重复,方便维护
2.客户端在实例化对象时,只依赖于接口,而不是具体类,让代码更有扩展性

    客户端不要依赖于具体实现
```
>#### 简单工厂: 简单工厂不是设计模式之一,但属于一种编程习惯
>#### 工厂方法
- 核心思想: 工厂方法模式定义了一个创建对象的接口,但是由子类来决定要实例化的类是哪个.工厂方法让类把实例化推迟到子类
- 类图:
  https://www.processon.com/diagraming/60c9ad580e3e7468a535ac57
>#### 抽象工厂
- 核心思想: 抽象工厂模式提供一个接口,用于创建产品簇,而不需要指定具体的类
- 类图:
  https://www.processon.com/diagraming/60c9bc245653bb3c31ea0a92
>#### 区别
- 工厂方法使用的是继承的方式,用于创建产品;抽象工厂用于创建产品簇,使用的是组合的方式
 
### 单例模式
- 单例模式常常用于值需要一个对象的情形,比方说:线程池、缓存
- 定义: 确保一个类只有一个实例,并提供一个全局访问点
- 类图
  https://www.processon.com/diagraming/60c9c15c0e3e747c8603177a
- [] 实现方式
- 饿汉式:类加载时创建单例,考虑资源问题
```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {
    }

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```
- 懒汉式:类使用时创建单例,但是需要考虑多线程问题,推荐使用双检锁
```java
public class Singleton {
    private static volatile Singleton INSTANCE;
    
    private Singleton() {
    }

    public static Singleton getInstance() {
        if(INSTANCE == null) {
            synchronized (Singleton.class) {
                if(INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```
- 静态内部类:使用静态内部类的特性创建单例,既实现了使用才加载,又避免使用锁
```java
public class Singleton {
    
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonFactory.INSTANCE;
    }
    
    private class SingletonFactory {
        private static final Singleton INSTANCE = new Singleton();
    }
}
```
- 其他方法: 枚举/反序列化,不推荐
### 构造器模式
- 意图: 将复杂对象的构建过程与它的部件分离
- 定义: 将复杂的对象构建过程封装起来
- 类图:
  https://www.processon.com/diagraming/60de7e9d0e3e745b08a224f3
  
### 原型模式

## 行为型模式
- 行为型模式用于描述程序在运行时复杂的流程控制,即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务,它涉及算法与对象间职责的分配
### 命令模式
-[ ] 目的: 将执行者与接收者隔离开来,实现解耦
-[ ] 核心思想:
 - 1.将"请求"封装成对象,将请求和接收者解耦;
 - 2.同时命令对象又使得能够对一系列请求进行操作,如对请求进行排队,记录请求日志以及支持可撤销的操作等。
  
```text
命令模式通过在特定的接收者(Receiver)上绑定一组动作来封装一个请求
要达到这一点,命令对象将动作和接收者包装起来,并暴露一个execute()方法,当该方法被调用时,Receiver就会执行这些动作

Command的调用者不需要知道究竟哪些接收者进行了哪些动作,值知道调用execute()方法,就能达到目的
```
- [ ] 类图
  https://www.processon.com/diagraming/60c9cfede401fd557e530d7d
  
-[ ] 命令模式的更多用途
- 队列请求
```text
将命令对象丢进队列,Receiver通过命令对象来传递

这样工作队列类和进行计算的对象之间是完全解耦的
```
- 日志请求
```text
某些应用需要我们将所有的动作都记录在日志中,并能在系统死机后,重新调用这些动作恢复到之前的状态

通过新增两个方法:store()和load()
```
-[ ] Q&A
- 1.Q.接收者一定要存在吗
- 1.A.一般来说,我们尽量设计一个"傻瓜"命令对象,有时候我们也可以使用"聪明"的对象,但这样命令模式和接收者之间不够解耦

### 模板方法
- 目的: 将算法封装起来,实现代码复用最大化
- 思想: 在一个方法中定义一个算法的骨架,而这些步骤将延迟到子类中
- 类图:
  https://www.processon.com/diagraming/60d3fd1c5653bb049a44e472
  
- 钩子方法: 父类中可以预留一个不做任何事情或缺省值的方法(称为钩子方法),子类可以视情况选择是否覆盖
```text
钩子方法的用途:
当算法的某个步骤是可选的,就可以使用钩子

钩子方法的目的
1)实现算法中的可选部分
2)让子类能够有机会对模板方法中的某些即将发生的步骤做出决定
```
- 注: 模板方法有很多变形(有时候面目全非),但其核心思想在于提供一个方法,并让子类实现某些步骤
### 策略模式
- 目的: 封装基于状态的行为,并将行为委托到当前状态
- 定义: 定义了算法簇,分别封装起来,让它们之间可以相互替换,此模式让算法的变化独立于使用算法的客户
- 类图:
  https://www.processon.com/diagraming/60dc27d907912929f4f0a129
### 状态模式
- 目的: 封装基于状态的行为,并将行为委托到当前状态
- 定义: 允许对象在内部状态改变时改变它的行为,对象看起来好像修改了它的类
- 类图:
  https://www.processon.com/diagraming/60dc267ee401fd7e34256924
- Q&A
- Q1.策略模式和状态模式的类图很像,他们有什么区别?
- A1. 主要的区别在于意图
```
策略模式的意图是实现除继承以外的一种弹性替代方案,它将可以互换的行为封装起来,然后使用委托的方法,决定使用哪个行为
状态模式的意图是将所有的状态封装到一个上下文中,在状态改变时,将行为委托到状态类,使得上下文类展现不同的行为.
```
### 迭代器模式
- 目的: 迭代的任务放在迭代器上而不是集合上,这样简化了集合接口的时间,也让责任各得其所
- 定义: 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露其内部的表示
- 类图:
  https://www.processon.com/diagraming/60d457f107912920c80765f2
-[ ] java中的迭代器
- java.util.Iterator接口,集合中会定义一个内部类来实现该接口,如ArrayList

### 责任链模式
- 定义: 为请求创建了一个接收者对象的链,对请求的发送者和接收者进行解耦
```text
通常每个接收者都包含对另一个接收者的引用
如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
```

### 迭代子模式
### 备忘录模式
### 中介者模式
- 意图: 处理众多对象之间彼此错综复杂的关系
- 定义: 是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。
- 类图:
- 何时使用: 多个类相互耦合，形成了网状结构
- 举例: 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。
### 解释器模式
- 用于实现一种语言或者DSL

- 类图:
  https://www.processon.com/diagraming/60de8453e401fd7e3429f9aa
## 结构型模式
结构型模式所描述的是如何将类和对象结合在一起来形成一个更大的结构
### 适配器模式
- 定义:适配器模式将一个类的接口,转换成客户期望的另一个接口.适配器让原本不兼容的类可以合作无间
- 类图:
  https://www.processon.com/diagraming/60d1aed7e401fd0e512c74c9
- 类适配器/对象适配器
```text
类装饰器是通过多继承来实现的
装饰器类继承Target类和Adaptee类,在Java中无法实现
```
### 装饰器模式
- 意图: 增强对象的行为
- 
- 类图:
  https://www.processon.com/diagraming/60dc3394f346fb04d2d0919c
### 代理模式
- 意图: 控制对对象的访问
- 定义: 为另一个对象提供一个替身或占位符以控制对这个对象的访问
- 类图:
  https://www.processon.com/diagraming/60dc34a0f346fb04d2d09741
  
- Q&A
- Q1:代理模式和装饰者模式有什么区别
- A1:虽然类图很像,但意图上有很大的区别
```text
装饰者的意图在于增强,一个对象可能被多个装饰者装饰
代理类的意图在于控制,一般一个代理类只有一个被代理对象,有时候代理类也承担被代理类的实例化工作
```
### 外观模式
- 定义:外观模式提供了一个统一的接口,用来访问子系统中的一群接口
```text
外观只是定义了一个高层接口,让子系统更容易使用

外观没有封装子系统,如果客户端需要一些自定义的功能,可以自行访问子系统
```
- 类图
  https://www.processon.com/diagraming/60d3ec925653bb049a448cb6
### 桥接模式
- 思想: 对于有多个维度变化的系统(抽象),将每个变化(实现)抽离出单独的类,使他们都能独立的变化
- 定义: 桥接模式将抽象和实现放在两个不同的类层次中而使得其能适应独立的变化
- 类图:
  https://www.processon.com/diagraming/60dd39cfe401fd7e34275dd4
  
- 如何理解抽象和实现
```text
抽象化：其概念是将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程。在面向对象就是将对象共同的性质抽取出去而形成类的过程。
实现化：针对抽象化给出的具体实现。它和抽象化是一个互逆的过程，实现化是对抽象化事物的进一步具体化。
脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。

实现系统可能有多个角度分类，每一种角度都可能变化，那么把这种多角度分类给分离出来让他们独立变化，减少他们之间耦合。
桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。
```
### 组合模式
- 定义: 组合模式将对象组合成树形结构来表现"整体/部分"层次结构.组合能让客户以一致的方式处理个别对象及对象组合
```text
文件系统,文件夹和文件 对java来说都是File,但文件夹是文件的组合
```
- 类图
  https://www.processon.com/diagraming/60d55152e0b34d7f11656f21
### 享元模式
- 意图: 用于减少创建对象的数量，以减少内存占用和提高性能
- 定义: 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象
- 类图:
  https://www.processon.com/diagraming/60deb0347d9c082853211044
