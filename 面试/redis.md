### 概述
- 1.为什么要使用Redis/为什么要用缓存
```text
A: 高性能 - Redis的读速度最高能达到11W次,写速度能达到8W次
   高并发 - Redis支持的并发量高
```
- 2.为什么不使用map或者guava的Chache做缓存
```text
A:
首先map并不具备一个缓存的能力 - 可预期的大小、热点、缓存过期清除等机制
第二map和cache都是实现的本地缓存,在集群的情况下不易做到缓存一致性,即使能够做到也会造成巨大的缓存浪费或者效率较低
```
- 3.Redis的优缺点
```text
优点:
    1.读写性能优异:11W次读,8W次写
    2.支持数据持久化,AOF和RDB两种持久化方式
    3.支持事务
    4.数据类型丰富,支持String,List,Set,ZSet和Hash
    5.支持主从复制,可以进行读写分离
缺点:
    1.受到物理内存的限制
```
- 4.Redis为什么速度快
```text
A:
    基于缓存:Redis的操作绝大部分是内存操作,并且使用key/value的直接映射方式
    单线程:采用单线程来处理指令,所以减少了上下文切换和锁竞争
    网络I/O:Redis采用epoll()作为I/O多路复用的技术实现
```
### 事务
- 1.什么是Redis事务?
```text
Redis事务是保证一个客户端的多条请求按顺序执行而不会被其他客户端打断的机制
Redis事务的本质:一组命令的集合,一个事务中的所有命令都会被序列化,在事务执行过程中会按照顺序执行

Redis事务不能保证原子性,在编译期错误则所有命令不执行,运行时错误则仅有错误的命令不执行
Redis事务不能保证一致性,出现部分错误可能会出现非预期的结果
Redis事务能保证隔离性,因为redis的命令执行器是单线程的
```
- 2.Redis的WATCH命令的作用?
```text
A:一般而言,可以在multi命令之前使用watch命令监控某些键值对,然后使用multi命令开启事务,这些命令就会进入队列
   当Redis使用EXEC命令执行任务的时候,它首先会去对比被watch命令所监控的键值对,如果没有发生变化,那么它会执行事务队列中的命令,提交事务
   如果发生变化,那么它不会执行任何事务中的命令.
        这类似于一种乐观锁
```
- 3.Redis事务的阶段?
```text
1.MULTI:事务开始
2.命令入队
3.EXEC:事务执行
```
### 集群
- 1.什么是哨兵模式
```text
哨兵模式是redis高可用性解决方案
哨兵模式由一个哨兵集群、master和若干台slave组成,一个哨兵集群可以监控一个或多个redis master服务,以及其从服务
哨兵集群一般由3个节点以上的哨兵组成,主要负责集群监控、消息通知、故障转译和配置中心
    集群监控:监控master和slave是否正常工作
    消息通知:如果某个redis实例有故障,可以发送告警消息给管理员
    故障转移:如果master node不能正常工作,会自动转移到slave node上
    配置中心:通知client刷新master地址

哨兵以一定的频率向所有的Master和Slave发送检测命令
如果一个实例距离最后一次有效回复时间超时(down-after-milliseconds),则这个实例会被哨兵定义为主观下线
如果一个Master被定义为主观下线,正在监视这个Master的哨兵会以每秒1次的频率确认Master是否下线
如果足够多的哨兵在指定时间内判定Master为主观下线,则将Master标记为客观下线
此时哨兵会发起领导者选举,选举一台哨兵进行故障迁移(这样可以保证只有1个sentinel节点去完成故障转移)

哨兵模式注意事项:
    只有Sentinel 集群中大多数服务器认定master主观下线时master才会被认定为客观下线，才可以进行故障迁移，也就是说，即使不管我们在sentinel monitor中设置的数是多少，就算是满足了该值，只要达不到大多数，就不会发生故障迁移。
    官方推荐至少部署三台.且分布在不同服务器
```
- 2.Redis Cluster(集群模式) - 针对海量数据+高并发+高可用的场景
```text
https://blog.csdn.net/weixin_42667608/article/details/111360617
Redis Cluster是一种服务端分片技术,Redis Cluster要求至少有3个master才能组成集群,同时每个master至少需要有一个slave点
Redis Cluster没有使用简单的一致性哈希,而是采用slot(槽)的概念,默认分为16384(2^14)个槽
主要思想:
    1.通过哈希的方式,将数据分片,每个节点均分存储一定的哈希槽区间内的数据,默认分配了16384个槽
    2.每份数据分片会存储在多个互为主从的多节点上
    3.数据先写入主节点,再同步到从节点(支持配置为阻塞同步)
    4.读取数据时,当客户端操作的key没有分配在该节点上时,redis会返回转向指令,指向正确的节点
    5.扩容时需要吧旧的节点上的slot迁移一部分到新节点上
    
优点:
    无中心架构,支持动态扩容,支持海量数据,对业务透明
    提供内置的高可用支持,部分master不可用时,集群仍然可以继续工作,如果master停止工作,会自动将对应的slave切换成master
    客户端不需要链接集群所有节点,链接集群中任何一个可用节点即可
缺点:
    Client端实现困难,不是特别稳定
    数据通过异步复制,不能保证强一致性
    slave仅做备份,不能缓解读压力
    对批量操作支持不友好
    不支持多数据库空间,单机下的redis可以支持到16个数据库,而cluster下只能使用一个数据库空间
算法:
Redis Cluster使用一种slot的概念来代替简单的一致性哈希,它将哈希环分为16384个槽,让每个redis节点管理其中的一部分
扩容:
Redis Cluster可以很容易进行横向扩容,当有新的节点加入,通过reshard来实现,redis有专门的工具(redis-trib)来进行数据转移
    首先redis-trib原cluster中的所有节点发送迁移槽位请求,同时向新节点发送导入槽位的请求.做好准备之后原master节点就开始执行迁移
    迁移完成后redis-tib会向集群中所有主节点发送槽位变更信息
高可用及故障转移:
    通过所有master充当哨兵,发现某个节点宕机了为主观下线,如果超过半数正常master认为该节点主观下线,该节点就会被标记为客观下线
    客观下线的节点的slave会被要求停止从master备份而升级为master节点提供服务
节点间通信:
    通过gossip(小道消息)通信
```
- 3.Redis的主从同步原理
```text
slave节点启动后会发送一个PSYNC命令给master node
如果这是slave node初次链接到master node,那么会触发一次 full resynchronization全量复制,此时master会异步的同步快照给slave,并在同步期间保存所有写操作,在slave同步完快照后再进行增量同步
如果slave在线的情况下则使用增量同步
```
- 4.Redis的读写分离
```text
https://www.cnblogs.com/williamjie/p/11250713.html
读写分离的架构由Proxy、HA、master、replica、Read-Only Replica构成

可以由星型模型和链式同步两种

星型模型就是每个ReadOnly-slave从主机同步数据,如果ReadOnly-Slave过多,会导致master压力过大,所以星型的slave会存在拓展问题
链式模型是将master->readOnly Slave链式的串联起来,每个slave从它的上一个节点同步数据,这样末端的节点数据延迟较高.但是扩展性好
    考虑到读写分离一般用在一致性要求不高的场景,所以redis一般使用链式复制模型

HA高可用模块用于监控所有DB节点的健康状态. 如果read-only节点宕机,HA也能及时感知

redis-proxy 会分辨用户请求是写还是读,如果是写分配到master,如果是读则通过权重因子将请求分配到各个节点
```
### 分布式
- 1.如何使用redis实现分布式锁
```text
使用SETNX(SET if Not eXists)命令来加锁
使用EXPIRE命令来设置锁的超时时间

使用DEL来删除key解锁
```
- 2.Redis作为分布式锁存在的问题和解决方案
```text
1.加锁:
    Redis在极端情况下会出现死锁,
    因为SETNX和EXPIRE两个命令无法保证原子性,如果进程执行了SETNX出现了宕机等异常情况,会导致锁永远无法被释放
    Redis 2.6.12之后的版本加入了可以设置超时时间的SETNX解决了这个问题
2.解锁
    Redis锁在极端情况下会出现误解锁
    假设A节点获取锁,设置超时时间为30s,运行时间超时31s,此时再执行解锁,可能会解锁到节点B上的锁
    可以先检查锁的value值,确认是否自己加的锁,如果是,则解锁
        但是这还有个问题,就是在获取值和解锁之间也不能保证原子性,所以有极小的概率出问题
    可以使用客户端执行Lua脚本来执行
        String luaScript = 'if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end';
        redisClient.eval(luaScript,Collections.singletonList(key), Collections.singletonList(threadId));
        
3.一种解决方案?
    可以通过守护线程给快过期的锁续费
    如果进程挂了,守护线程也会退出(其实也并不完美,有可能进程没挂,只是卡假死了),就不会续费]
    
4.其他情况:
    如果在锁定的时候master挂了并且没有同步到slave,那么这个锁就被丢失了
```
- 3.什么是RedLock
```text
RedLock是(Redis Lock)的缩写,Redis官方推荐了一种可靠的分布式锁实现方式
实现RedLock需要部署N台没有主从关系的redis集群(5个)
当客户端获取锁时,同时向5个master发送获取锁消息,并设置超时时间(远小于锁的时间)
当且仅当在超时时间内从(N/2+1)个Redis节点都取到锁,并且使用的时间(锁超时时间-超时时间)小于锁失效时间,锁才算获取成功
如果获取到了锁,在使用完后释放锁
如果没有获取到锁(<N/2+1),客户端应该在所有redis实力上进行解锁

<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.3.2</version>
</dependency>
已经实现了这种redLock
```
### 缓存异常
- 1.缓存雪崩
```text
缓存雪崩是缓存在同一时间大面积失效,导致请求都落到DB上的情况,造成数据库短时间承受大量请求而崩溃
解决方案:
    1.缓存标记:记录缓存数据是否过期,如果过期会触发通知另外的线程在后台去更新实际key的缓存
    2.缓存数据:缓存标记的时间低于缓存数据的时间(比如一半),通过后台进程去更新数据.这样做可以一定程度提高系统吞吐量
    3.加锁排队:如果并发量不大,可以使用加锁排队的方式去查
    4.缓存数据时间随机:不要使用完全一致的缓存时间
```
- 2.缓存穿透
```text
请求缓存和数据库中都没有的数据,导致所有的请求都落到数据库上,造成数据库短时间内承受大量请求
解决方案:
    1.对于缓存穿透的数据设置value为null并设置超时时间
    2.使用布隆过滤器,将一定不存在的数据过滤掉,从而避免对底层存储系统的查询压力
    
布隆过滤器
    布隆过滤器是将一个key使用多个哈希算法计算后分别放在哈希桶的多个位置
    当校验key是否存在时,通过同样的算法去哈希桶中查找对应的位置均为1,则认为key存在
    布隆过滤器会存在误报的问题,不存在漏报的问题.数据越密集,误报的几率越大
    布隆过滤器只能添加不能删除
```
- 3.缓存击穿
```text
数据库中有但是缓存中没有数据,由于并发用户太多,导致数据库压力瞬间增大,造成过大压力

解决方案:
    设置热点数据永不过期
    从数据库读数据的逻辑加数据锁,让仅有一次查询后放入缓存
```
### 常用工具
### 数据类型
- 1.Redis支持的数据类型有哪些
```txt
A: 字符串 哈希 列表 集合 有序集合
```
### 持久化
- 1.Redis的持久化机制有哪些
```text
A:
 1.RDB: 采用本地存储(dump.rdb)的方式来持久化,一般是满足了某些门限后进行持久化
    优点: 
        RDB非常适合容灾,它只有一个文件,并且内容非常紧凑,可以在加密后存储到其他介质(如S3)
        性能最大化,fork一个子进程来进行持久化,主进程不参与I/O可以保证redis的高性能
        RDB在恢复大数据集时的速度比AOF要高
    缺点:
        数据安全性低,RDB是达到门限后才持久化,在异常宕机后会丢失部分数据
        每次保存RDB的时候,redis会fork()出一个子进程,当数据集比较庞大时,fork()操作可能非常耗时
 2.AOF: 通过日志的方式将Redis执行的每次写命令记录.当重启Redis会重新将持久化的日志中文件恢复数据
    优点:
        数据安全性高,aof可以配置持久化策略以保证不同的安全性(no/everysec/always),默认是每秒记录一次
        AOF文件只会追加,所以不需要进行seek()操作,并且在异常情况下写入了未完整的命令日志也易于恢复(redis-check-aof)
        Redis在AOF文件体积变得过大后,自动在后台进行文件重写,重写后的文件包含了恢复当前数据集所需的最小命令集合
        AOF文件有序的保存了写操作,使得AOF可以被轻易的修改(这是一个优点,比如误操作键入flush,在AOF中删除flush即可)
    缺点:
        AOF文件体积通常大于RDB文件体积
        根据采用的同步策略,AOF的速度可能会慢于RDB,要保证最小时延,使用RDB时比较好的选择
        AOF可能会引入不确定的BUG,RDB则不会,因为RDB只是快照
        AOF的恢复速度要慢于RDB
 3.AOF和RDB同时开启,会优先通过AOF(Appending only file)来恢复数据
```
- 2.Redis持久化数据和缓存如何做扩容
```text
A:如果Redis仅被当成缓存使用,使用一致性哈希实现动态扩容
  如果Redis需要持久化存储,必须使用固定的keys-to-nodes映射关系,节点的数量一旦确定不能发生变化
    否则的话redis,必须使用可以在运行时数据再平衡的一套系统(redis集群) ???
```
- 3.拓展:什么是一致性哈希算法
```text
哈希算法将所有的值分散成一个0~2^32-1的环
第一步将所有的服务器根据某个属性计算哈希(如ip),这样每台机器就可以确定在哈希环上的位置
第二步将所有的数据(如redis的key)计算哈希,并确定在哈希环的位置,然后顺时针查找到node的位置,找到的第一台服务器就是目标服务器

当有服务宕机或需要扩容时,受到影响的仅仅是两个节点直接的数据,一致性哈希对教育节点的增减都只需要重定位环空间的一小部分数据,具有良好的容错性和可扩展性
https://www.cnblogs.com/lpfuture/p/5796398.html

一致性哈希在节点过少时,容易出现数据倾斜的问题
```

### 过期键的删除策略
- 1.过期键的清除策略有哪些
```text
A:
1.定时过期 - 对每一个数据的key创建一个定时器,到过期时间就会立即清除;这种策略对内存友好但是对CPU不友好
2.惰性过期 - 只有当访问一个Key时才会检查是否过期,过期则清除;可以节省CPU但是对内存非常不友好
3.定期过期 - 每隔一定时间,会扫描一定数量的数据库的expires字典中一定数量的key,清除其中已过期的key.该策略是一个折中方案.

Redis使用了惰性过期+定期过期策略
```
### 内存相关
- 1.Redis内存淘汰策略
```text
1.noeviction: 当内存不足以容纳新写入数据,新写入操作会报错
2.allkeys-lru: 当内存不足以容纳新写入数据时,在键空间中,移除最少使用的key(最常用)
3.allkeys-random:在键空间中随机移除某个key
4.volatile-lru: 在设置了过期时间的键空间中,移除最近最少使用的key
5.volatile-random: 在设置了过期时间的建空间中,随机移除key
6.volatile-ttl: 移除有更早过期时间的key
```
- 2.Redis如何做内存优化?
```text
通常情况下很多小的Key-Value可以使用更紧凑的方式存放,比如value可以使用散列表
加入你的web系统里面有一个用户对象,不要为这个用户名称,姓氏,邮箱,密码单独设置key,而是将用户的所有信息放在一个散列表中
```
### 线程模型
- 1.Redis的线程模型?
```text
A: Redis的线程模型
    多个Socket: 用于接收客户端的请求
    IO复用程序: 用于非阻塞的获取Socket的状态,如果Socket准备就绪,将Socket的事件放入队列中
    文件事件分派器: 逐个获取队列中的事件,并分派给事件处理器
    事件处理器(包括 连接应答处理器,命令请求处理器,命令回复处理器)
        连接应答处理器: 将事件请求与请求处理器关联
        命令请求处理器: 读取Socket中的数据,根据命令完成key,value的设置、读取等操作,将socket的AE_WRITEABLE事件与命令回复处理器关联
        命令回复处理器: 命令回复处理器对socket输入文件此次操作的结果,之后解除socket的AE_WRITEABLE事件与命令回复处理器的关联
https://baijiahao.baidu.com/s?id=1676709704453688282&wfr=spider&for=pc
```
### 其他问题
- 1.如何保证缓存与数据库双写时的数据一致性？
```text
1.如果系统不是严格要求数据一致性,缓存可以稍微的根数据库偶尔有不一致的情况
2.读请求和写请求串行化.大大降低系统吞吐量.
3.先更新数据库,再删除缓存.可能是一个比较好的做法
```
- 2.Redis常见性能问题和解决方案
```text
1.Master最好不要做持久化,如果一定要持久化在某个Slave上开启AOF备份数据,策略为每秒一次
2.为了主从复制的速度和链接稳定性,master和slave最好在一个局域网内
3.尽量避免在压力较大的主库上增加从库
4.为了Master的稳定性,主从复制不要使用星状结构,而使用链式结构
```
- 3.redis的一些其他功能
```text
使用zset做排行榜
使用list做队列
```