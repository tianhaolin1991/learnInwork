## 多线程
### 简述JMM模型
```text
JVM内存由两个部分组成,1是主内存,相当于总线,2是线程的工作内存,每个线程都有自己的工作内存
工作内存中保存被该线程使用的变量的内存副本,线程对变量的所有操作都在内存空间进行,不能直接写入主内存
操作完成之后,线程的工作内存通过缓存一致性协议将操作完成的数据写入主内存
```
### 简述as-if-serial(Skip)
```text
编译器等会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果和用户原始程序输出预定结果一致。
```
### 简述happen-before八大原则(Skip)
```text
程序次序规则：一个线程内写在前面的操作先行发生于后面的。
锁定规则： unlock 操作先行发生于后面对同一个锁的 lock 操作。
volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作。
线程启动规则：线程的 start 方法先行发生于线程的每个动作。
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
线程终止规则：线程中所有操作先行发生于对线程的终止检测。
对象终结规则：对象的初始化先行发生于 finalize 方法。
传递性规则：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C
```
### as-if-serial 和 happens-before 的区别
```text
as-if-serial保证单线程执行结果不变
happens-before保证正确同步的多线程程序执行结果不变
```
### 简述原子性、可见性、有序性
```text
原子性:一个操作或者多个操作,要么全部执行,要么就不执行
可见性:当一个线程在工作内存中修改了某个变量时,确保其他工作内存中能够立刻得知修改.volatile/synchronized/final都能保证可见性
有序性:本线程内观察该线程的左右执行操作是有序的
```
### 简述volatile关键字的作用
```text
1.保证了变量的可见性,某个线程在工作内存中修改该变量时,其他线程会立刻得到新值
2.禁止重排序优化.使用volatile变量进行写操作,汇编指令会带有Lock前缀,相当于一个内存屏障,编译器不会将后面的指令重排序
```
### java线程的实现方式
```text
1.继承Thread类
2.实现Runnable接口的run()方法
3.实现Callable接口的call()方法
```
### 简述Java线程的状态
```text
NEW: 新建状态
RUNNABLE: 可执行或执行中状态
BLOCKED: 锁阻塞状态,等待获取锁
WAITING: 等待状态,线程内调用join()/Object.wait()会进入该状态
TIMED-WAITING: 限期等待状态,线程内调用Thread.sleep(long)& Object.wait(long)会进入该状态
TERMINATED: 结束状态,线程调用完run方法进入该状态
```
### 简述线程池的设计理念和原理
```text
线程池是使用的是线程复用的思想,当异步任务到来时,作为一个Command来执行,从而减少线程创建和销毁而带来的开销

线程池有几个核心的概念
核心线程数:核心线程是预创建的线程,线程池会保证池中至少有核心线程数个线程
最大线程数:当核心线程数不能满足使用时,会创建新的线程,直到最大线程数,新创建的线程会在IDLE状态保持一段时间后销毁
等待队列:当线程池中运行的任务超过最大线程数,新到来的任务会被放入等待队列中
拒绝策略:当等待队列也满时,会执行拒绝策略,常见的拒绝策略有
    AbortPolicy: 丢弃任务,并抛出RejectedExecutionException
    DiscardPolicy: 丢弃任务,但不会抛出异常
    DiscardOldestPolicy: 丢弃队列最前面的任务,然后重新提交被拒绝的任务
    CallerRunsPolicy: 由调用线程处理该任务
    
线程池关闭:
    shutDown()和shutDownNow()==>不建议使用
    
    当调用shotDown时,线程池的状态变为SHUTDOWN状态.该状态下的线程池不再接收新的任务
    正在执行的线程将会等待当前任务执行完后退出,IDLE状态的线程会直接被关闭
    清空所有等待队列中的任务(ScheduledThreadPool)/不清空等待队列中的任务(ThreadPoolExecutor)
    等待所有正在运行中的任务结束后,线程池才会正式关闭
```
### Executors默认的几种线程池及使用场景
```text
1.Executors.newFixedThreadPool(int core): 固定核心线程数的ThreadPoolExecutor,其队列为一个LinkedBlockingQueue,大小为Integer.MaxValue
  不建议直接使用这种方法创建线程池
2.Executors.newCachedThreadPool(): 创建一个核心线程数为0,最大线程数为Integer.MAX_VALUE的ThreadPooleExecutor,该线程池可以灵活创建线程,如果线程不够则创建新线程
  线程池的最大线程数无限大,不利于资源管理
3.Executors.ScheduledThreadPool(int core): 创建一个线程数定长的ScheduledThreadPoolExecutor,
4.Executors.newSingleThreadExecutor(): 生成一个单线程的线程池ThreadPoolExecutor的代理线程池
线程数的创建原则:
对于CPU密集的任务,可以减少线程并发量,从而提高线程中任务的运行速度一般为N*CPU+1
对于IO密集型的任务,可以增加线程量,2N*CPU,因为每个线程任务都存在IO等待,这样可以提高CPU利用率
```
