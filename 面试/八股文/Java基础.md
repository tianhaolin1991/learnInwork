## JAVA基础语法

### 基本数据结构

- [ ] 基本类型
- boolean: 1个字节,1位
- byte: 1个字节,8位有符号数
- short: 2个字节,16位有符号数
- int: 4个字节,32位有符号数
- long: 8字节,64位有符号数

```text
long类型值必须显示的声名(当超出int范围时)
long l = 65536L; //正确
long l = 65536; //编译错误
long l = 65535; //编译正确:这是扩充类型的情况
```

- float: 4字节,32位,符合IEEE 754标准

```text
负数: -3.402823e+38到-1.401298e-45
正数: 1.401298e-45 到 3.402823e+38
```

- double:8字节,64位,符合IEEE 754标准

```text
负数 -1.797693e+308 到 -4.9000000e-324
正数 4.9000000e-324 到 1.797693e+308
```

- char: 2字节,16位,0-2^16-1之间

- [ ] 直接数(代码里的数字常量)
- 所有基本类型(除了boolean)都可以用直接量直接赋值
- 如果赋值超出数据类型的范围,则会出现编译错误

```text
char c1 = 65536  // × 编译失败
char c2 = 65535 // √
byte b1 = 128 // × 编译失败
byte b2 = 127 // √
```

- [ ] 基本类型数据之间的转换
- 按照范围大小的次序是: byte < short < int < long < float < double
- 将小范围类型转化为大范围类型称为拓宽类型,不需要显性声明类型转换;将大类型转换为小类型称为缩窄类型,必须显性声名类型转换,否则会导致编译错误

```text
int i1 = 100;
long l1 = i1;
short s1 = (short)i1;
float f1 = i1;
double d1 = i1;
```

- 字符类型(char)和数字类型可以转换,将数字类型转换为char类型时,只能使用整数的低16位;当将字符类型转换为整数类型时,如果字符的统一码超出了转换成的数值类型,则必须显性声名类型转换

```text
byte b = 'b';
short s = '\u8000'; // 错:编译失败
short s = (short)'\u8000';
```

- boolean不可以做转换

### 方法

- [ ] 方法的语法结构
- 方法包括<font color='red'>方法头和方法体</font>

```text
方法头: 修饰符 返回值类型和参数列表

包括五个部分:
修饰符: private/public/protect/空
返回值类型: 可以是任意类型,或者是void
方法名: 方法的名称
参数列表: 定义在昂发头中的变量称为形参;调用方法时,传递给方法的参数称为实参
方法体:方法体包含具体的语句集合
```

- 方法签名:由方法名和参数列表构成
- [ ] 参数值传递
- JAVA中都是值传递,对于基本类型,直接传递值;对于其他类型,传递指向该对象的地址
- [ ] 方法的重载和重写
- Override(重写): 发生在继承和实现中,覆盖父类或实现接口的方法

```text
重写的方法遵循三小一一致原则
三小: 
1.修饰符必须是和父类相同或者大于父类
2.入参的返回值必须是父类或者接口返回类型或其子类
3.抛出的异常必须是更具体的异常(或者选择不抛出)
一不变:
入参的类型必须与父类一致
  why? 如果子类中调用超类super.xx,那么如果参数为父类方法的父类,那么可能会出现数据不兼容
                               如果参数为父类方法的子类,那么没有必要..因为本来就能接收子类
```

- Reload(重载): 因为方法的签名由方法名和参数类型组成,重载的方法必须有不同的参数列表或者参数名

```text
注意:仅当参数列表类型完全相同的时候才会出现重载冲突
    如果参数列表是父子关系,还是可以找到最优的参数,以入参不需要强制转换的优先级为高
```

### 面向对象

- [ ] 继承
- 1.类实例化的顺序

```text
1.父类静态代码块、父类静态变量:按照书写顺序
2.子类静态代码块、子类静态变量:按照书写顺序
3.父类成员代码块、父类成员变量:按照书写顺序
5.父类构造函数
6.子类成员变量、子类代码块
7.子类构造函数
```

- 2.方法重写(见line 72)
- 3.关键字final:关键字final表示不变的.

```text
修饰类:不可以被继承
修饰方法:不能被重写
修饰成员:不能被修改
```

- 4.接口冲突

```text
如果一个类实现了两个接口,这两个接口有相同签名的方法,但是返回值不同.会出现编译错误
```

### 线程的状态

- NEW: 新建状态
- RUNNABLE: 执行状态或可执行状态
- BLOCKED: 锁阻塞状态
- WAITING: 等待状态
- TIMED-WAITING: 计时等待
- TERMINATED: 终止状态

## JAVA进阶-源码及原理

### 简述HashMap的原理

```text
描述: HashMap是通过对key进行哈希之后将Entry放入哈希桶的一种容器
原理: 当我们调用put方法时,会先计算key的hash值,如果哈希桶不存在,则构建一个新的哈希桶
        具体的哈希算法是key的hashCode与其自身的低16位取异或,该hash算法是个扰动函数,防止key自身的hash算法分布不理想
     计算完key的哈希值后会拿hash值与桶长度-1去与,计算出key在桶中的位置
        非常巧妙的设计,哈希桶的长度是2的倍数,这样哈希桶长度-1就可以作为一个掩码,在哈希桶扩容后,掩码正好也左移一位,使得哈希桶中的元素刚好不动或向后移动固定的位置
     如果桶中对应的索引没有元素,则会创建一个新的节点作为头节点放入桶中,并且检查哈希桶是否需要扩容
     如果桶中对应的索引有元素,则会从头节点遍历数组或红黑树,插入或者更新节点
        发现相同的key(哈希值相等,并且==或equals)则更新节点中的值,否则在树中或链表的尾部插入新节点
        在链表添加中有可能会进化为红黑树(TREEIFY_THRESHOLD)
关键参数:
    DEFAULT_INITIAL_CAPACITY = 16; 如果构造函数中指定了16的非整数倍,也会向上取整为16的2^n倍
    DEFAULT_LOAD_FACTOR = 0.75; 负载因子,当哈希桶中不为null的头节点超过了桶容量的0.75倍会将桶容量翻倍以减少哈希冲突
    TREEIFY_THRESHOLD = 8; 链表长度超过8会红黑树
    UNTREEIFY_THRESHOLD = 6; 红黑树中的节点少于6会退化为链表
    MIN_TREEIFY_CAPACITY = 64; 如果哈希桶容量小于该阈值,而桶中的某个位置的节点数大于TREEIFY_THRESHOLD,那么不会树形化,而是直接对桶进行扩容
    
相关问题:
Q1: HashMap是如何扩容的?为什么?
A1: HashMap在以下两种情况会扩容
       1)当桶容量小于MIN_TREEIFY_CAPACITY并且某个位置的节点数量超过了TREEIFY_THRESHOLD
       2)当桶中非空头结点与桶容量的比大于负载因子
    HashMap的扩容方式是将哈希桶容量变为原来的两倍,并且将桶中的元素重新定位.
       因为HashMap的容量是2的倍数,并且通过tab.length()-1作为掩码进行位置分配,所以桶中的元素要么保持在原位置不变,要么向后移动oldLength个位置
       扩容的时候HashMap使用头插法,将旧数组中的元素一一转移到新数组中
Q2: HashMap为什么会存在并发问题?
A2: HashMap的并发问题就存在于扩容的时候,需要进行元素的转移.
    在高并发时,多个线程同时进行扩容,有几率会导致桶中某个位置出现循环链表
```
